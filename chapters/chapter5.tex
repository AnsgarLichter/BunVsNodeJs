% !TeX root = ..\main.tex
\npchapter{Schlussbetrachtung} \label{ch:finalThoughts}
Im letzten Kapitel dieser Arbeit werden die Ergebnisse der vorangegangenen Kapitel zusammengefasst und reflektiert. Darauffolgend wird ein Ausblick auf die Zukunft von Bun und über mögliche weitergehende Forschungsthemen gegeben.

\section{Fazit} \label{sec:finalThoughts-conclusion}
Diese Arbeit evaluiert Bun im Vergleich zu dem etablierten Standard Node.js. Dabei liegt der Fokus auf zwei Hauptaspekten: Performance und Kompatibilität. Die Performance wurde durch mehrere Benchmarks analysiert, während die Kompatibilität durch die Migration existierender Node.js-Projekte zu Bun überprüft wurde.\\

\noindent
Die Performance-Tests beantworten die erste der drei Leitfragen \glqq Welche konkreten Leistungsverbesserungen können in Bun 1.0 im Vergleich zu Node.js festgestellt werden, und wie lassen sie sich quantifizieren?\grqq{} (siehe \autoref{sec:introduction-target}). Die Ergebnisse zeigen, dass Bun in allen Szenarien eine signifikant bessere Leistung als Node.js aufweist (siehe \autoref{sec:performance-results}). Dies äußert sich in einer deutlich verringerten Latenz, einer geringeren Inanspruchnahme von Arbeitsspeicher und CPU-Ressourcen. Dies gilt sowohl für die Verarbeitung von Netzwerkanfragen als auch für die Ausführung rechenintensiver Aufgaben. Bun besitzt das Potenzial, in realen Szenarien erheblich schneller zu sein als Node.js. Insbesondere die effiziente Nutzung der Ressourcen könnte erhebliche Auswirkungen auf die Skalierbarkeit und Kosten in Produktionsumgebungen besitzen.\\

\noindent
Die zweiten Leitfrage  \glqq Inwiefern sind Node.js-Projekte kompatibel mit Bun? Wie schwierig gestaltet sich die Migration?\grqq{} (siehe \autoref{sec:introduction-target}) beschäftigt sich mit der Kompatibilität von bestehenden Node.js-Projekten. Die Analyse (siehe \autoref{ch:compabitility}) zeigt, dass die Migration bestehender Projekte in der Regel Anpassungen in den Abhängigkeiten und Konfigurationen erfordert. Der Aufwand dafür hängt stark von der spezifischen Anwendung und den genutzten Abhängigkeiten ab. Die Migration der untersuchten Express- und Nest-Anwendungen war erfolgreich, erforderte aber aktive Eingriffe. Darüber hinaus führt die Verwendung des Bundlers im Nest-Projekt zu Fehlern. Das wirft Fragen zur Zuverlässigkeit und Stabilität von Bun auf.\\

\noindent
Zusammenfassend lässt sich die dritte Leitfrage \glqq Welche Herausforderungen und Vorteile ergeben sich bei der Verwendung von Bun 1.0 im Vergleich zu Node.js für Entwickler und Projekte?\grqq{} (siehe \autoref{sec:introduction-target}) wie folgt beantworten: Bun ist aufgrund seiner hohen Performance eine gute Alternative im Vergleich zu Node.js. Allerdings benötigt Bun etwas Zeit, um offene Fehler zu lösen und die Kompatibilität mit der Node.js-API und anderen Frameworks zu verbessern. Für neuen Projekten ohne zusätzliche Frameworks, kann Bun aufgrund der besseren Performance bereits in Betracht gezogen werden.


\section{Ausblick} \label{sec:finalThoughts-outlook}
In zukünftigen Forschungsarbeiten kann es interessant sein, die Performance und Kompatibilität von tatsächlich produktiv verwendeten Applikationen zu analysieren. Diese weisen oft komplexere Lösungen auf und verwenden bereits ein Framework oder andere Bibliotheken, das die Performance der verwendeten Laufzeitumgebung beeinflussen kann. Darüber hinaus können weitere Aspekte, wie die Sicherheit, Stabilität oder Buns Paketmanager betrachtet werden. Zusätzlich können die Performance und Kompatibilität von Buns Bundler und der integrierten Bibliothek zum Testen analysiert werden und mit etablierten Lösungen verglichen werden. Dadurch ist eine komplette Bewertung von Bun mit allen integrierten Komponenten möglich.\\

\noindent
Schließlich bleibt abzuwarten, wie sich Bun weiterentwickelt und ob es sein Versprechen hinsichtlich Performance und Kompatibilität auch in zukünftigen Versionen erfüllt. Zukünftige Updates können die identifizierten Probleme lösen und die Kompatibilität verbessern. Denn die Roadmap für die Entwicklung besitzt viele offene Punkte. Gleichzeitig existieren zahlreiche offene Fehler, beispielsweise die Funktionsfähigkeit des Bundlers (siehe \autoref{sec:compabitility-nest}). Daher ist es sinnvoll, die Leistung und den Migrationsprozess in regelmäßigen Abständen neu zu analysieren, um die Entwicklungsfortschritte zu bewerten.
