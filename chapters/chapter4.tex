% !TeX root = ..\main.tex
\npchapter{Kompatibilität von Projekten}  \label{ch:compabitility}
Dieses Kapitel behandelt die Kompatibilität zwischen Node.js und Bun. Es beschäftigt sich mit der Beantwortung der zweiten Leitfrage \glqq Inwiefern sind Node.js-Projekte kompatibel mit Bun? Wie schwierig gestaltet sich die Migration?\grqq{}. Nur wenn der Migrationsaufwand für den Wechsel der Laufzeitumgebung möglichst gering ist, kann Bun Node.js als Platzhirsch verdrängen. Die Betrachtung konzentriert sich auf die Kompatibilität häufig verwendeter Backend-Frameworks, da diese auf einem Server direkt von Bun oder Node.js ausgeführt werden. Laut \cite{Greif.2022} handelt es sich dabei um Express und NestJS.

\section{Express} \label{sec:compabitility-express}
Express ist ein beliebtes Open-Source-Framework für Node.js, das die Entwicklung von Webanwendungen und APIs vereinfacht. Es stellt eine Vielzahl von Funktionen und Tools zur Verfügung, die Entwicklern bei der Handhabung von HTTP-Anfragen und -Antworten, Routing und weiteren Aufgaben zu helfen. Express nutzt ausschließlich die HTTP-Schnittstelle der Node.js-API. Diese implementiert Bun bereits (siehe Kapitel \ref{sec:foundations-Bun}).\cite{Brown.November2019}\\

\noindent 
Um die Kompatibilität von Express mit Bun zu testen, wird eine einfache Anwendung genutzt, die das Erstellen, Aktualisieren, Lesen und Löschen von Büchern und Autoren über eine API ermöglicht. Die API verwendet Express in Verbindung mit TypeScript. Sie wird um einige Middleware-Funktionalitäten erweitert, um die Migration repräsentativer zu gestalten. Dazu gehören:
\begin{itemize}
	\item Winston als Logger,
	\item Helmet zum Schutz der API,
	\item Morgan zur Protokollierung der ein- und ausgehenden HTTP-Anfragen,
	\item Mongoose als ORM zur Speicherung von Daten in MongoDB, \todo{Abkürzungsverzeichnis und erklären?}
	\item Joi zur Validierung der Bücher und Autoren in den HTTP-Anfragen,
	\item Compression zur Komprimierung der HTTP-Antworten,
	\item ein zentraler Error-Handler, um bei Fehlern verständliche Nachrichten an den Benutzer zurückzugeben.
\end{itemize}
	
\noindent
Um die App von Node.js auf Bun zu migrieren, muss Buns integrierter Paketmanager verwendet werden, um die passenden Abhängigkeiten zu installieren. Node.js speichert die installierten Abhängigkeiten in der \glqq package.json\grqq{}, die auch von Buns Paketmanager genutzt wird. Für eine komplette Neuinstallation werden der Ordner \glqq node\_modules\grqq{} und die Datei \glqq package-lock.json\grqq{} gelöscht. In diesem Ordner speichert Node.js alle lokal installierten Abhängigkeiten. Node.js nutzt die \glqq package-lock.json\grqq{}, um die installierten Abhängigkeiten lokal zu speichern. Dies sorgt dafür, dass auf anderen Geräten die Versionen installiert werden, die während der Entwicklung verwendet wurden. \newline
Im zweiten Schritt müssen veraltete Abhängigkeiten aus dem Projekt entfernt und weitere benötigte Abhängigkeiten hinzugefügt werden. Die Typdefinitionen von Node.js und die Pakete, die es unter Node.js ermöglichen, TypeScript auszuführen (siehe Kapitel \ref{sec:foundations-Node.js}), werden unter Bun nicht mehr benötigt. Als Abhängigkeit müssen die Typdefinitionen von Bun hinzugefügt werden. Diese werden auch in der Datei \glqq ts-config.json\grqq{} inkludiert, damit global auf Buns API ohne Kompilierungsfehler zugegriffen werden kann. Diese Datei definiert Einstellungen und Optionen für den TypeScript-Compiler. Die Werte der Konfigurationsoptionen, die sowohl in der aktuellen Datei als auch in in Buns Empfehlungen vorhanden sind, werden an den empfohlenen Wert angepasst \cite{OvenSh.2023}.\newline 
Im dritten Schritt werden die Befehle in der \glqq package.json\grqq{} angepasst, die die Ausführung des Projekts ermöglichen. Zum Ausführen des Projekts wird ab sofort \glqq bun --watch src/index.ts\grqq{} genutzt. Zuletzt müssen die Pakete mit Buns Paketmanager installiert werden, indem der Befehl \glqq bun install\grqq{} ausgeführt wird. Danach kann die Anwendung gestartet werden.\\

\noindent
Der erste Start der App ist nicht erfolgreich. Die Konsolenausgabe zeigt den Fehler an \glqq SyntaxError: Import named Request not found in module node\_modules/express/index.js\grqq{}. Das bedeutet, dass der Compiler den Import des Typs \glqq Request\grqq{} aus dem Express-Framework nicht auflösen kann. Um die generelle Funktionsweise der App zu überprüfen, werden die Importe aller Typen aus dem Express-Framework entfernt. Ein erneuter Start der App bestätigt die generelle Funktionsweise. Da es sich um ein Problem mit den Typdefinition handelt, liegt die Vermutung nahe, dass eine Einstellung des TypeScript-Compilers die Ursache ist. Eine minimale Express-App mit der empfohlenen Konfiguration des TypeScript-Compilers zeigt, dass die App auch mit den verwendeten Typen funktioniert. Der Vergleich der Konfiguration des Compilers in beiden Projekten zeigt, dass im aktuellen Projekt \glqq emitDecoratorMetadata\grqq{} aktiviert ist. Diese Option steuert, ob der Compiler Metadaten über Dekoratoren im generierten JavaScript-Quellcode generiert. Ist diese Option aktiviert, kann zur Laufzeit auf die Metadaten der Dekoratoren zugegriffen werden. Mit deaktivierter Option startet die App. Das Absenden von HTTP-Anfragen an die Applikation zeigt, dass alle API-Operationen erfolgreich funktionieren. Offiziell unterstützt Bun diese Option seit der Version 1.0.3 und wurde auch erfolgreich getestet (siehe Kapitel \ref{sec:compabitility-nestjs}) \cite{McDonnel.2023}. Möglicherweise liegt hier auch ein Fehler im Express-Framework vor.\\

\noindent
Wenn man die App nun produktiv nutzen möchte, verwendet man minifizierten Quellcode, der mit Hilfe eines Bundlers erstellt wird. Bun bietet einen integrierten Bundler an (siehe Kapitel \ref{sec:foundations-Bun}). Dieser wird durch den Befehl \glqq bun build src/index.ts --outdir ./dist --target bun\grqq{} erzeugt. Dabei ist es wichtig, Bun als Zielplattform zur Ausführung zu spezifizieren, da alternativ auch Node.js als Zielplattform genutzt werden kann. Führt man nun das Ergebnis des Bundlers aus, erscheint eine kryptische Fehlermeldung: \glqq TypeError: d is not a function. (In d(target, key, r), d is an instance of Object)\grqq{}. Die Analyse zeigt, dass ein verwendeter Dekorator nicht funktioniert. Dieser sorgt dafür, dass beim Binding der Listener für die API-Funktionen  der this-Kontext innerhalb des Listeners funktioniert. Dies muss nun manuell über angepassten Quellcode erledigt werden. Nun startet die App in der produktiven Nutzung ohne Fehler. Das Absenden von HTTP-Anfragen an die Applikation zeigt, dass auch alle API-Operationen erfolgreich funktionieren. Offiziell handelt es sich bei der Option \glqq experimentalDecorators\grqq{} um ein experimentelles Feature, das von Node.js bereits unterstützt wird und von Bun noch nicht \cite{Microsoft.2023}.

\section{NestJS} \label{sec:compabitility-nestjs}
NestJS ist ein Open-Source-Framework für die Entwicklung von serverseitigen Anwendungen und APIs in Node.js \cite{Mysliwiec.2023}. Es wurde entwickelt, um die Erstellung von skalierbaren, gut strukturierten und leicht wartbaren Anwendungen zu erleichtern. NestJS basiert auf TypeScript und bietet eine Abstraktionsebene über gängige HTTP-Servern wie z. B. Express an. Alternativ können Entwickler über APIs andere Server integrieren und benuzten. Bun unterstützt NestJS noch nicht vollständig \cite{Sumner.2022}. Mit Version 1.0.3 wird der TypeScript-Dekorator \glqq emitDecoratorMetadata\grqq{} unterstützt, auf dem NestJS aufbaut \cite{McDonnel.2023}. Dadurch wird der Support von NestJS verbessert.\\

\noindent
Zur Prüfung der Kompatibilität wird eine App verwendet, die es ermöglicht über eine API Artikel zu erstellen, aktualisieren, lesen und zu löschen. Der Autor ist ein Benutzer, der sich zuvor registrieren muss. Die Anwendung verwendet die folgenden Features:

\begin{itemize}
	\item Rollenbasierte Authentifizierung und Autorisierung,
	\item ORM-Integration mit TypeORM,
	\item Logging mit Winston,
	\item Validierungen mit Joi.
\end{itemize}

\noindent
Als Datenbank wird eine lokale PostgreSQL-Instanz verwendet. Den Verbindungsaufbau übernimmt TypeORM unter Angabe der korrekten Daten. Die Schritte der Migration entsprechen bis zum ersten Starten der Applikation der Migration von Express (siehe Kapitel \ref{sec:compabitility-express}). Daher werden im Folgenden nur die Unterschiede betrachtet. Die Konfiguration des Compilers entspricht den Empfehlungen. Lediglich die Optionen, die Bun als Best Practices deklariert, werden nicht übernommen. Denn diese sind in den Best Practices von NestJS explizit nicht enthalten. \newline
Beim Start der App erscheint nun die Fehlermeldung \glqq Error: Cannot find module node\_modules/bcrypt/lib/binding/napi-v3/bcrypt\_lib.node\grqq{}. Das Paket \glqq bcrypt\grqq{} wird verwendet, um die Passwörter zu hashen und beim Login zu validieren. Bcrypt nutzt node-gyp als Abhängigkeit \cite{DelGobbo.2018}. Dabei handelt es sich um ein Open-Source-Build-Tool, das zum Erstellen und Kompilieren nativer Node Module eingesetzt wird \cite{OpenJSFoundation.o.J.b}. In diesem Kontext wird oft \glqq postinstall\grqq{} verwendet, eine Lifecycle-Methode beim Installieren der Abhängigkeiten. Im Anschluss an die Installation des Pakets wird ein Skript ausgeführt, um beispielsweise node-gyp auszuführen. Bun blockiert diese standardmäßig, da diese Skripte potentielle Sicherheitsrisiken darstellen \cite{OvenSh.2023}. Vertraut man einem Paket, muss man dieses in der \glqq package.json\grqq{} als vertraute Abhängigkeit deklarieren. Fügt man nun Bcrypt hinzu und installiert alle Pakete komplett neu, ist der Fehler gelöst. \newline
Die Konsolenausgabe zeigt beim nächsten Start der App einen Laufzeitfehler an: \glqq ReferenceError: Cannot access uninitialized variable.\grqq{}. Dies tritt an der Stellen auf, in denen die Relation zwischen den Entitäten \glqq Article\grqq{}und \glqq User\grqq{} definiert werden. Das führt zu einer zirkulären Abhängigkeit zwischen \glqq User\grqq{} und \glqq Article\grqq{}. \cite{TypeORM.} zeigt, dass zirkuläre Abhängigkeiten vermieden werden können, wenn bei der Definition der Relation der Typ \glqq User\grqq{} durch \glqq Relation<User>\grqq{} ersetzt wird. Dann löst TypeORM die Definitionen entsprechend auf, ohne dabei zirkuläre Abhängigkeiten zu erzeugen.\\

\noindent
Die Konsole zeigt beim erneuten Start der Applikation keine Fehler mehr. Sendet man nun HTTP-Anfragen an die API, wird die Fehlermeldung \glqq Die Metadaten für die Entität User können nicht gefunden werden.\grqq{} zurückgegeben. TypeORM sucht aktuell alle Entitäten über ein String, der ein Pattern für den Pfad der Entitäten definiert. Laut \cite{TypeORM.2021} ist diese Variante veraltet. Die Entitäten müssen direkt als Referenz übergeben werden, indem sie über einen Import inkludiert werden. \newline
Startet man die App erneut und führt HTTP-Anfragen aus, erhält man keine Fehlermeldungen mehr. Allerdings stürzt der Server mit der Meldung \glqq Segmentation Fault\grqq{} ab, sobald sich ein neuer Benutzer registriert oder ein vorhandener Benutzer einloggt. Über die Log-Einträge kann nachvollzogen werden, dass der Server abstürzt, sobald Bcrypt zum Hashen der Passwörter aufgerufen wird. Laut \cite{Sumner.2023} funktioniert Bcrypt nicht, wenn es asynchron aufgerufen wird. Ein synchroner Aufruf der entsprechenden Funktionen verläuft allerdings erfolgreich. Da ein synchroner Aufruf dieser Funktion die Ausführung anderer Aufgaben blockiert, ist diese Lösung nicht optimal. Bun bietet für diesen Zweck eine eigene API an. Nutzt man diese in der Applikation, sind auch die HTTP-Anfragen zum Registrieren oder Einloggen von Benutzern erfolgreich. Die anderen Endpunkte der API funktionieren auch. Daraus folgt, dass NestJS unter Bun funktioniert. Allerdings bedeutet der Wechsel auf die API von Bun, dass das Versprechen eines Eins-zu-Eins-Ersatzes für Node.js nicht gehalten werden kann, da die Migration aktive Eingriffe in die Abhängigkeiten der Applikation erfordert.\\

\noindent
Als letzten Punkt wird, wie bei Express zuvor, versucht die minifizierte Version der Anwendung zu erzeugen und lokal auszuführen. Sobald man den Bundler aufruft, zeigt dieser zahlreiche Fehlermeldungen an. Der Bundler meldet viele Abhängigkeiten, die er nicht auflösen kann.  Auffällig ist, dass die als fehlend deklarierten Abhängigkeiten in den direkten Abhängigkeiten des Projekts nicht vorhanden sind. \cite{Postek.2023} zeigt, dass bereits andere Entwickler mit demselben Problem konfrontiert sind. Da dieses Problem derzeit ungelöst ist, funktioniert der Bundler für NestJS nicht. Hier muss gewartet werden, bis eine entsprechende Lösung per Update nachgereicht wird.

\section{Fazit} \label{sec:compabitility-conclusion}
Dieses Kapitel beschäftigt sich mit der zweiten Leitfrage \glqq Inwiefern sind Node.js-Projekte kompatibel mit Bun? Wie schwierig gestaltet sich die Migration?\grqq{} (siehe \autoref{sec:introduction-target}). Die Migration von Node.js-Projekten auf Bun kann erfolgreich sein, erfordert jedoch in der Regel Anpassungen in den Abhängigkeiten und Konfigurationen. Der Aufwand hängt stark von der Applikation und den verwendeten Abhängigkeiten ab. Beispielsweise erfordert die Umstellung der NestJS-Applikation zusätzliche Anpassungen, insbesondere bei der asynchronen Verwendung von Bcrypt. Obwohl die Anwendung unter Bun funktioniert, ist festzustellen, dass die Migration aktive Eingriffe in die Abhängigkeiten der Anwendung erfordert. Zusätzlich funktioniert der Bundler nicht.  Die Tatsache, dass die minifizierte Version der NestJS-Anwendung unter Bun nicht funktionierte, wirft Fragen zur Stabilität und Zuverlässigkeit von Bun auf. Es bleibt abzuwarten, ob zukünftige Updates diese Probleme beheben können.\\

\noindent
Es gilt anzumerken, dass die verwendeten Beispiele einfachere Applikationen waren. Produktiv genutzte Anwendungen können komplexer sein und auch mehr Abhängigkeiten verwenden. Beide Beispiele beweisen, dass häufig verwendete Komponenten und Konzepte funktionieren. Dazu zählen Authentifizierung und Autorisierung, Logging, CRUD-Operationen für Entitäten, Integration mit einer Datenbank und auch Schutzmechanismen für die Applikation selbst. Auf diesen Konzepten bauen auch produktiv genutzte Anwendungen auf. Sobald es über diese Konzepte hinausgeht, muss die Funktionsweise unter Bun separat analysiert werden.