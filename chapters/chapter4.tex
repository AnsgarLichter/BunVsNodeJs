% !TeX root = ..\main.tex
\npchapter{Kompatibilität von Projekten}  \label{compabitility}
Dieses Kapitel betrachtet die Kompatibilität zwischen Node.js und Bun. Es ist von hoher Bedeutung, dass Bun möglichst viele Frameworks und Pakete aus dem Ökosystem von Node.js unterstüzt. Nur wenn der Migrationsaufwand für den Wechsel der Laufzeitumgebung möglichst gering und einfach ist, kann Bun Node.js als Platzhirsch verdrängen. Die Betrachtung konzentriert sich auf die Kompatibilität häufig verwendeter Backend-Frameworks, da diese auf einem Server direkt von Bun oder Node.js ausgeführt werden. Laut der Umfrage ``State of JavaScript 2022'' handelt es sich dabei um Express und NestJS \cite{Greif.2022}.

\section{Express} \label{sec:compabitility-newProjects}
Express ist ein beliebtes Open-Source-Framework für Node.js. Das Framework möchte die Erstellung von Webanwendungen und APIs in Node.js vereinfachen. Dafür stellt es eine Vielzahl von Funktionen und Tools zur Verfügung, die Entwicklern die Handhabung von HTTP-Anfragen und -Antworten, Routing und weiteren Aufgaben helfen. Express nutzt von nur die HTTP-Schnittstelle der Node.js API. Laut der Dokumentation von Bun ist diese Schnittstelle bereits implementiert. Demnach sollte die Migration funktionieren.\\

\noindent 
Um die Kompatibilität von Express mit Bun zu testen, wird eine einfache Anwendung genutzt, die über eine API das Erstellen, Aktualisieren, Lesen und Löschen von Büchern und ihren Autoren ermöglicht. Die API nutzt Express und TypeScript. Sie wird um einige Middleware-Funktionalitäten erweitert, um die Migration repräsentativer zu gestalten. Die folgenden Komponenten werden verwendet:
\begin{itemize}
	\item Winston als Logger, um die Bearbeitung der Anfragen transparent zu gestalten und die Fehleranalyse bei der Migration zu vereinfachen,
	\item Helmet, um die API zu schützen,
	\item Morgan, um die ein- und ausgehenden HTTP-Anfragen zu loggen,
	\item Mongoose als ORM, um die Daten in einer MongoDB speichern zu können,
	\item Joi, um die Bücher und Autoren in den HTTP-Anfragen zu validieren,
	\item Compression, um die HTTP-Antworten zu komprimieren,
	\item einen zentralen Error-Handler, um bei Fehlern möglichst verständliche Nachrichten in der HTTP-Anfrage zu inkludieren.
\end{itemize}
	
\noindent
Um die App von Node.js auf Bun zu migrieren, muss Buns integrierter Paketmanager verwendet werden, um die passenden Abhängigkeiten zu installieren. Node.js speichert die installierten Abhängigkeiten in der ``package.json''. Diese kann auch Buns Paketmanager nutzen. Für eine komplette Neuinstallation muss der Ordner ``node\_modules'', in dem sich die lokal installierten Abhängigkeiten befinden,  gelöscht werden. Zusätzlich wird die Datei ``package-lock.json'' entfernt. Node.js nutzt diese Datei werden lokal die installierten Abhängigkeiten zu speichern. Dies beschleunigt die Installation der Pakete und sorgt dafür, dass die Versionen installiert werden, die während der Entwicklung verwendet wurden. Zusätzlich erhöht die ``package-lock.json'' die Sicherheit, da sie die Installation aus vertrauenswürdigen Quellen sicherstellt. Bun nutzt für diesen Mechanismus eine andere Datei. \newline
Im zweiten Schritt müssen obsolete Abhängigkeiten aus dem Projekt entfernt und weitere benötigte Abhängigkeiten hinzugefügt werden. Die Typdefinitionen von Node.js und die Pakete, die es unter Node.js ermöglichen TypeScript auszuführen (siehe Kapitel \ref{sec:foundations-Node.js}). Denn diese werden unter Bun nicht mehr benötigt. Als Abhängigkeit müssen die Typdefinitionen von Bun hinzugefügt werden. Diese werden auch in der Datei ``ts-config.json'' inkludiert werden, damit global auf Buns API ohne Fehler des Kompilers zugegriffen werden kann. Diese Datei definiert Einstellungen und Optionen für den TypeScript-Kompiler. Zusätzlich werden die Einstellungen an die Empfehlungen aus der Dokumentation von Bun angepasst \todo{Quelle hinzufügen}. \newline 
Im dritten Schritt werden die Befehle in der ``package.json'' angepasst, die die Ausführung des Projekts ermöglichen. Hierbei wird dafür gesorgt, dass Bun als Laufzeitumgebung verwendet wird. Zuletzt müssen die Pakete mit Buns Paketmanager installiert werden, indem der Befehl ``bun install'' ausgeführt wird. Nachfolgend kann nun über ``bun run dev'' der angepasste Befehl aus der ``package.json'' genutzt werden, um die API zu starten.\\

\noindent
Der erste Start der App ist nicht erfolgreich. Die Konsolenausgabe zeigt den Fehler an ``SyntaxError: Import named 'Request' not found in module 'node\_modules/express/index.js''. Das bedeutet, dass der Kompiler den Import des Typs 'Request' aus dem Express-Framework nicht auflösen kann. Um die generelle Funktionsweise der App zu verifizieren, werden die Importe aller Typen aus dem Express-Framework entfernt. Ein erneuter Start der App zeigt, dass die App erfolgreich ausgeführt werden kann. Da es sich um ein Problem mit den Typdefinition handelt, liegt die Vermutung nahe, dass eine Einstellung des TypeScript-Kompilers \todo{Rechtschreibung prüfen} die Ursache ist. In einem schnellen Test, in dem mit Hilfe des Leitfadens von Bun eine mimimale Express-App generiert und ausgeführt wird \todo{Quelle hinzufügen}, funktionieren diese Importe. Ein Vergleich der ``ts-config.json'' beider Projekte zeigt, dass im aktuellen Projekten ``emitDecoratorMetadata'' aktiviert ist. Diese Option steuert, ob der Kompiler Metadaten über Dekoratoren im generierten JavaScript-Quellcode generiert. Ist diese Option aktiviert, kann zur Laufzeit auf die Metadaten der Dekoratoren zugegriffen werden. Wenn diese Informationen zur Laufzeit nicht benötigt werden, ist es empfohlen, die Option zu deaktivieren. Mit der deaktivierten Option läuft diese App nun. Das Absenden von HTTP-Anfragen an die Applikation zeigt, dass alle API-Operationen erfolgreich funktionieren.\\

\noindent
Wenn man die App nun produktiv nutzen möchte, verwendet man minifizierten JavaScript-Quellcode. Dieser wird mit Hilfe eines Bundlers erstellt. Bun bietet einen integrierten Bundler an (siehe Kapitel \ref{sec:foundations-Bun}). Abbildung TODO zeigt den Befehl mit dem Bundler. Wichtig ist hierbei, Bun als Zielplattform zu spezifizieren. Denn alternativ kann auch Node.js als Zielplattform ausgewählt werden, um den Code produktiv mit Node.js auszuführen. Führt man nun das Ergebnis des Bundlers aus, erscheint eine kryptische Fehlermeldung: ``TypeError: d is not a function. (In 'd(target, key, r)', 'd' is an instance of Object)''. Eine Analyse zeigt, dass ein verwendeter Dekorator nicht funktioniert. Der verwendete Dekorator sorgt, dass beim Binding der Listener für die API-Funktionen auch der Kontext der Klasse gesetzt wird, sodass der this-Kontext innerhalb des Listeners funktioniert. Dies muss nun manuell über angepassten Quellcode erledigt werden. Nun startet die App in der produktiven Nutzung ohne Fehler. Das Absenden von HTTP-Anfragen an die Applikation zeigt, dass auch alle API-Operationen erfolgreich funktionieren. Offiziell handelt es sich bei der Option ``experimentalDecorators'' \todo{Quelle hinzufügen} um ein experimentelles Feature, das von Node.js bereits unterstützt wird und von Bun noch nicht.

\section{NestJS} \label{sec:compabitility-existingProjects}
Nest.js ist ein Open-Source-Framework für die Entwicklung von serverseitigen Anwendungen und APIs in Node.js. Es wurde entwickelt, um die Erstellung von skalierbaren, gut strukturierten und leicht wartbaren Anwendungen zu erleichtern. Nest.js basiert auf TypeScript und bietet eine Abstraktionsebene über gängige HTTP-Servern wie z. B. Express an. Nest ermöglicht den Entwicklern über APIs andere Server zu benutzen. So haben die Entwickler Wahlfreiheit für die zugrunde liegende Plattform. \todo{Quelle} Bun unterstützt offiziell Nest.js noch nicht vollständig. \todo{https://github.com/oven-sh/bun/issues/1641} Mit Version 1.0.3 wird der TypeScript-Dekorator ``emitDecoratorMetadata'' unterstützt, auf den Nest.js aufbaut. \todo{https://bun.sh/blog/bun-v1.0.3} Dadurch soll es möglich sein Nest.js mit ORMs \todo{Erklären?} grundsätzlich zu nutzen. Denn aus der Node-API wird auch nur die HTTP-Schnittstelle benötigt, sofern keine Message Broker wie Kafka genutzt werden. Denn diese Message Broker nutzen ``tel'' und ``net'' aus der Node.js API, die von Bun nicht vollständig implementiert sind \todo{Quelle Bun Doku und GitHub Issue}.\\

\noindent
Zur Prüfung der Kompatibilität wird eine App verwendet, die es ermöglicht über eine API Artikel zu erstellen, aktualisieren, lesen und zu löschen. Der Autor ist ein Benutzer, der sich zuvor Registrieren muss. Die Anwendung verwendet die folgenden Features:

\begin{itemize}
	\item Authentifizierung und Autorisierung über Tokens \todo{RBAC?},
	\item ORM-Integration mit TypeORM,
	\item Logging mit Winstong,
	\item Validierungen mit Joi und Class-Validator \todo{Was macht der?}.
\end{itemize}

\noindent
Als Datenbank wird eine lokale PostgreSQL-Instanz verwendet. Den Verbindungsaufbau übernimmt TypeORM unter Angabe der korrekten Daten. Die Migration startet wie bei Express mit dem Löschen der installierten Abhängigkeiten und der ``package-lock.json''. Im zweiten Schritt werden die nicht mehr benötigten Abhängigkeiten, z. B. die Typendefinitionen von Node.js, entfernt. Es werden wieder die Typdefinitionen von Bun hinzugefügt. Im dritten Schritt wird die ``ts-config.json'' an die Empfehlungen von Bun angepasst und die Typdefinitionen von Bun inkludiert. Die Optionen, die Bun als Best Practices bezeichnet, werden nicht übernommen. Denn diese sind in den Best Practices von Nest.js explizit nicht enthalten. Im vierten Schritt werden die Befehle in der ``package.json'' angepasst, um die Applikation starten zu können. Abschließend werden die Abhängigkeiten über Buns Paketmanager installiert.\newline
Beim Start der App erscheint nun die Fehlermeldung ``Error: Cannot find module 'node\_modules/bcrypt/lib/binding/napi-v3/bcrypt\_lib.node'''. Das Paket ``bcrypt'' wird verwendet, um die Passwörter zu hashen und beim Login zu validieren. Bcrypt nutzt node-gyp als Abhängigkeit \todo{Quelle: https://github.com/kelektiv/node.bcrypt.js}. Dabei handelt es sich um ein Open-Source-Build-Tool, das zum Erstellen und Kompilieren nativer Node Module eingesetzt wird \todo{Quelle?}. In diesem Kontext wird oft postinstall verwendet, eine Lifecycle-Methode beim Installieren der Abhängigkeiten. Im Anschluss an die Installation des Pakets wird ein Skript ausgeführt, um beispielsweise einen Build auszuführen. Bun blockiert diese standardmäßig, da diese Skripte potentielle Sicherheitsrisiken darstellen. Vertraut man einem Paket, muss man dieses in der ``package.json'' als vertraute Abhängigkeit deklarieren \todo{https://bun.sh/guides/install/trusted}. Fügt man nun Bcrypt hinzu und installiert alle Pakete komplett neu, ist der Fehler gelöst. \newline
Die Konsolenausgabe zeigt beim erneuten Start der App einen Laufzeitfehler an: ``ReferenceError: Cannot access uninitialized variable.''. Abbildung TODO zeigt die Stelle, die diese Fehlermeldung verursacht. Die Entität ``Article'' definiert eine Relation zu der Entiät ``User''. Das führt zu einer zirkulären Abhängigkeit zwischen ``User'' und ``Article''. Die Dokumentation von TypeORM zeigt, dass zirkuläre Abhängigkeiten vermieden werden können, wenn ``User'' durch ``Relation<User>'' ersetzt wird. Dann löst TypeORM die Definitionen entsprechend auf, ohne dabei zirkuläre Importe zu erzeugen. \\

\todo{Code Listing Entity Definition}

\noindent
Die Konsole zeigt beim erneuten Start der Applikation keine Fehler mehr an. Sendet man nun HTTP-Anfragen an die API, wird die Fehlermeldung ``Die Metadaten für die Entität User können nicht gefunden werden.'' zurückgegeben. TypeORM sucht alle Entitäten über ein String geladen, der ein Pattern für den Pfad der Entitäten sucht. Laut Changelog von TypeORM ist diese Variante veraltet \todo{Quelle Changelog TypeORM}. Die Entitäten müssen direkt als Referenz übergeben werden, indem sie über einen Import inkludiert. \newline
Startet man die App erneut und führt HTTP-Anfragen aus, erhält man keine Fehlermeldungen mehr. Allerdings stürzt der Server mit der Meldung ``Segmentation Fault'' ab, sobald ein sich ein neuer Benutzer registrieren oder ein vorhandener Benutzer einloggen möchte. Über die Logs kann nachvollzogen werden, dass der Server abstürzt, sobald Bcrypt zum Hashen der Passwörter aufgerufen wird. Eine Recherche zu dieser Fehlermeldung in Kombination mit Bcrypt hat keine Treffer ergeben und die neuste Version wird bereits verwendet. Daher bleibt nur die Option in der Dokumentation von Bun nach Empfehlungen für das Hashen von Passwörtern zu suchen. Bun bietet hierfür tatsächlich eine eigene API an. Nutzt man diese in der Applikation, sind auch die HTTP-Anfragen zum Registrieren oder Einloggen von Benutzern erfolgreich. Die anderen Endpunkte der API funktioniert auch. Daraus folgt, dass Nest.js unter Bun funktionieren kann. Allerdings bedeutet der Wechsel auf die API von Bun, dass das Versprechen eines Eins-zu-Eins-Ersatzes für Node.js nicht gehalten werden kann. Denn es erfordert aktive Eingriffe in die Abhängigkeiten der Applikation. \\

\noindent
Als letzten Punkt wird, wie bei Express zuvor, versucht die minifizierte Version der Anwendung zu erzeugen und lokal auszuführen. Sobald man den Bundler aufruft zeigt dieser viele Fehlermeldungen an, die in Abbildung TODO zu sehen sind. Auffällig ist, dass die Abhängigkeiten, die hier als fehlend deklariert werden, in den direkten Abhängigkeiten des Projekts nicht vorhanden sind. \todo{Quelle: https://github.com/oven-sh/bun/issues/4803} zeigt, dass bereits andere Entwickler dasselbe Problem besitzen. Da dieses Issue aktuell noch offen ist, funktioniert Buns Bundler für Nest.js noch nicht. Hier gilt es Updates abzuwarten.

\section{Fazit} \label{sec:compabitility-conclusion}
Dieses Kapitel beschäftigt sich mit der zweiten Leitfrage ``Inwiefern sind Node.js-Projekte kompatibel mit Bun? Wie schwierig gestaltet sich die Migration?'' (siehe Kapitel \ref{sec:introduction-target}). Die Ergebnisse dieses Kapitels zeigen, dass Bun Applikationen auf der Basis von Express oder Nest.js ausführen kann. Der Migrationsaufwand hängt stark von der Applikation und den verwendeten Abhängigkeiten ab. Funktionieren nahezu alle Abhängigkeiten problemlos, wie zum Beispiel bei Express, ist die Migration in kurzer Zeit erledigt. Sobald bestimmte Module nicht kompatibel sind und Fehler verursachen, kann der Prozess für die Suche nach der Ursache und die Implementation einer Lösung sehr mehrere Stunden in Anspruch nehmen. Letzendlich hängt die Funktionsfähigkeit eines Moduls davon ab, welche Schnittstelle der Node.js API genutzt werden. Wenn Bun die verwendeten Schnittstellen implementiert hat, funnktionieren die Module. Andernfalls kann die Suche nach der Ursache und nach alternativen Lösungsansätzen zeitintensiv und schwierig werden. Selbst wenn alle verwendeten APIs unterstütz werden, kann es wie bei Bcrypt zu Laufzeitfehlern kommen. Deren Analyse ist als Entwickler, der nicht das Modul selbst entwickelt, äußerst schwierig.\\

\noindent
Es gilt anzumerken, dass die verwendeten Beispiele einfachere Applikationen waren. Produktiv genutzt Anwendungen können komplexer sein und auch mehr Abhängigkeiten verwenden. Beide Beispiele beweisen, dass häufig verwendete Komponenten und Konzepte funktionieren. Dazu zählen Authentifizierung und Autorisierung, Logging, CRUD-Operationen für Entitäten, Integration mit einer Datenbank und auch Schutzmechanismen für die Applikation selbst. Auf diesen Konzepten bauen auch produktiv genutzte Anwendungen auf. Sobald es über diese Konzepte hinausgeht, muss die Funktionsweise unter Bun separat analysiert werden.