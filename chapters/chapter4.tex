% !TeX root = ..\main.tex
\npchapter{Kompatibilität von Projekten} \label{ch:compabitility}
Dieses Kapitel behandelt die Kompatibilität zwischen Node.js und Bun. Es beschäftigt sich mit der Beantwortung der zweiten Leitfrage \glqq Inwiefern sind Node.js-Projekte kompatibel mit Bun? Wie schwierig gestaltet sich die Migration?\grqq{} (siehe \autoref{sec:introduction-target}). Nur wenn der Migrationsaufwand für den Wechsel der Laufzeitumgebung möglichst gering ist, kann Bun Node.js als Marktführer verdrängen. Die Betrachtung konzentriert sich auf die Kompatibilität häufig verwendeter Backend-Frameworks, da diese auf einem Server direkt von Bun oder Node.js ausgeführt werden. Laut \cite{Greif.2022} handelt es sich dabei um Express und Nest.

\section{Express} \label{sec:compabitility-express}
Express ist ein beliebtes Open-Source-Framework für Node.js, das die Entwicklung von Webanwendungen und APIs vereinfacht. Es stellt eine Vielzahl von Funktionen und Tools zur Verfügung, die Entwicklern bei der Handhabung von HTTP-Anfragen und -Antworten, Routing und weiteren Aufgaben helfen. Express nutzt ausschließlich die HTTP-Schnittstelle der Node.js-API. Diese implementiert Bun bereits im Standard (siehe Kapitel \ref{sec:foundations-Bun}).\cite{Brown.2020}\\

\noindent 
Um die Kompatibilität von Express mit Bun zu testen, wird eine einfache Anwendung genutzt, die die Create, Read, Update, Delete-Operationen (CRUD-Operationen) für Büchern und Autoren über eine API ermöglicht \acused{crud}. Die API verwendet Express in Verbindung mit TypeScript. Sie wird um einige Middleware-Funktionalitäten erweitert, um die Migration repräsentativer zu gestalten. Dazu gehören:
\begin{itemize}
	\item Winston als Logger,
	\item Morgan zur Protokollierung der ein- und ausgehenden HTTP-Anfragen,
	\item Helmet zum Erhöhen der Sicherheit durch Setzen von Header in der HTTP-Antwort,
	\item Mongoose als Tool für das \ac{orm} zur Speicherung von Daten in MongoDB,
	\item Joi zur Validierung der Bücher und Autoren in den HTTP-Anfragen,
	\item Compression zur Komprimierung der HTTP-Antworten,
	\item ein zentraler Error-Handler, um bei Fehlern verständliche Nachrichten an den Benutzer zurückzugeben.
\end{itemize}
	
\noindent
Bun's integrierter Paketmanager muss für die Installation der passenden Abhängigkeiten verwendet werden, um die App von Node.js auf Bun zu migrieren. Node.js speichert die installierten Abhängigkeiten in der Datei \glq package.json\grq{}, die auch von Bun's Paketmanager genutzt wird. Da die Migration aktuell manuell durchgeführt werden muss, ist eine vollständige Neuinstallation der Abhängigkeiten erforderlich. Dafür werden die Ordner \glq node\_modules\grq{} und die Datei \glq package-lock.json\grq{} gelöscht. In diesem Ordner speichert Node.js alle lokal installierten Abhängigkeiten. Node.js nutzt die Datei \glq package-lock.json\grq{}, um die installierten Abhängigkeiten lokal zu speichern. Dies sorgt dafür, dass auf anderen Geräten die Versionen installiert werden, die während der Entwicklung verwendet wurden. \newline
Im zweiten Schritt müssen veraltete Abhängigkeiten aus dem Projekt entfernt und weitere benötigte Abhängigkeiten hinzugefügt werden. Die Typdefinitionen von Node.js und die Pakete, die es unter Node.js ermöglichen, TypeScript auszuführen (siehe Kapitel \ref{sec:foundations-Node.js}), werden unter Bun nicht mehr benötigt. Als Abhängigkeit müssen die Typdefinitionen von Bun hinzugefügt werden. Diese werden auch in der Datei \glq ts-config.json\grq{} inkludiert, damit global auf Bun's API ohne Fehler zugegriffen werden kann. Diese Datei definiert Einstellungen und Optionen für den TypeScript-Transpiler. Die Werte der Konfigurationsoptionen, die sowohl in der aktuellen Datei als auch in Bun's Empfehlungen vorhanden sind, werden an die empfohlenen Werte angeglichen \cite{OvenSh.2023e}.\newline 
Im dritten Schritt werden die Befehle in der \glq package.json\grq{} angepasst, sodass die Ausführung des Projekts mit Bun möglich ist. Zum Ausführen des Projekts wird ab sofort \glq bun --watch src/index.ts\grq{} genutzt. Zuletzt müssen die Pakete mit Bun's Paketmanager installiert werden, indem der Befehl \glq bun install\grq{} ausgeführt wird. Danach kann die Anwendung gestartet werden.\\

\noindent
Der erste Start der App ist nicht erfolgreich. Die Konsolenausgabe zeigt den Fehler \glq SyntaxError: Import named Request not found in module node\_modules/express/index.js\grq{} an. Das bedeutet, dass der Compiler den Import des Typs \glq Request\grq{} aus dem Express-Framework nicht auflösen kann. Um die generelle Funktionsweise der App zu überprüfen, werden die Importe aller Typen aus dem Express-Framework entfernt. Ein erneuter Start der App bestätigt die generelle Funktionsweise. Da es sich um ein Problem mit den Typdefinitionen handelt, liegt die Vermutung nahe, dass eine Einstellung des TypeScript-Compilers die Ursache ist. Eine minimale Express-App mit der empfohlenen Konfiguration des TypeScript-Compilers zeigt, dass die App auch mit den verwendeten Typen funktioniert. Der Vergleich der Konfiguration des Compilers in beiden Projekten zeigt, dass im aktuellen Projekt \glq emitDecoratorMetadata\grq{} aktiviert ist. Diese Option steuert, ob der Compiler Metadaten über Dekoratoren im generierten JavaScript-Quellcode erzeugt. Ist diese Option aktiviert, kann zur Laufzeit auf die Metadaten der Dekoratoren zugegriffen werden. Mit deaktivierter Option startet die App. Das Absenden von HTTP-Anfragen an die Applikation zeigt, dass alle API-Operationen funktionieren. Offiziell unterstützt Bun diese Option seit der Version 1.0.3 (siehe Kapitel \ref{sec:compabitility-nest}) \cite{McDonnel.2023}.\\

\noindent
Zur produktiven Nutzung der App wird einen Bundler verwendet, um mit dessen Hilfe einen minifizierten Quellcode zu erstellen. Bun bietet einen integrierten Bundler (siehe Kapitel \ref{sec:foundations-Bun}). Dieser wird durch den Befehl \glq bun build src/index.ts --outdir ./dist --target bun\grq{} erzeugt. Dabei ist es wichtig, Bun als Zielplattform zur Ausführung zu spezifizieren, da alternativ auch Node.js als Zielplattform genutzt werden kann. Sobald das Ergebnis des Bundlers ausgeführt wird, erscheint die folgende Fehlermeldung: \glq TypeError: d is not a function. (In d(target, key, r), d is an instance of Object)\grq{}. Die Analyse zeigt, dass ein verwendeter Dekorator nicht funktioniert. Dieser sorgt dafür, dass beim Binding der Listener für die API-Funktionen der this-Kontext innerhalb des Listeners funktioniert. Dies muss manuell über eine Anpassung des Quellcodes erledigt werden. Ein erneuter Start der App mit dem minifizierten Quellcode ist erfolgreich. Das Absenden von HTTP-Anfragen an die Applikation zeigt, dass auch alle API-Operationen erfolgreich funktionieren. Offiziell handelt es sich bei der Option \glq experimentalDecorators\grq{} um ein experimentelles Feature, das von Node.js bereits unterstützt wird und von Bun noch nicht \cite{Microsoft.2023}.

\section{Nest} \label{sec:compabitility-nest}
Nest ist ein Open-Source-Framework für die Entwicklung von serverseitigen Anwendungen und APIs in Node.js \cite{Mysliwiec.2023}. Es wurde entwickelt, um die Erstellung von skalierbaren, gut strukturierten und leicht wartbaren Anwendungen zu erleichtern. Nest basiert auf TypeScript und bietet eine Abstraktionsebene über gängige HTTP-Server wie z. B. Express an. Alternativ können Entwickler über APIs andere Server integrieren und benuzten. Bun unterstützt Nest noch nicht vollständig \cite{Sumner.2022b}. Seit der Version 1.0.3 wird der TypeScript-Dekorator \glq emitDecoratorMetadata\grq{}, auf dem Nest aufbaut, unterstützt \cite{McDonnel.2023}.\\

\noindent
Zur Prüfung der Kompatibilität wird eine App verwendet, die es ermöglicht über eine API die \ac{crud}-Operationen für Artikel anzuwenden. Der Autor ist ein Benutzer, der sich zuvor registrieren muss. Die Anwendung verwendet die folgenden Features:

\begin{itemize}
	\item Rollenbasierte Authentifizierung und Autorisierung,
	\item ORM-Integration mit TypeORM,
	\item Logging mit Winston,
	\item Validierungen mit Joi.
\end{itemize}

\noindent
Als Datenbank wird eine lokale PostgreSQL-Instanz verwendet. Den Verbindungsaufbau übernimmt TypeORM. Die Schritte der Migration entsprechen der Migration von Express (siehe Kapitel \ref{sec:compabitility-express}). Daher werden im Folgenden nur die Unterschiede betrachtet. Die Konfiguration des Compilers entspricht Bun's Empfehlungen. Lediglich die Optionen, die Bun als Best Practices deklariert, werden nicht übernommen. Denn diese sind in den Best Practices von Nest explizit nicht enthalten. \newline
Beim Start der App erscheint nun die Fehlermeldung \glq Error: Cannot find module node\_modules/bcrypt/lib/binding/napi-v3/bcrypt\_lib.node\grq{}. Das Paket \glq bcrypt\grq{} wird verwendet, um die Passwörter zu hashen und beim Login zu validieren. \glq Bcrypt\grq{} nutzt \glq node-gyp\grq{} als Abhängigkeit \cite{DelGobbo.2018}. Dabei handelt es sich um ein Open-Source-Build-Tool, das zum Erstellen und Kompilieren nativer Node Module eingesetzt wird \cite{OpenJSFoundation.o.J.c}. In diesem Kontext wird oft \glq postinstall\grq{} verwendet, eine Lifecycle-Methode beim Installieren der Abhängigkeiten. Im Anschluss an die Installation des Pakets wird ein Skript ausgeführt, um beispielsweise \glq node-gyp\grq{} auszuführen. Bun blockiert diese standardmäßig, da die dabei ausgeführten Skripte potentielle Sicherheitsrisiken darstellen \cite{OvenSh.2023}. Wenn ein Paket vertrauenswürdig ist, muss dieses in der \glq package.json\grq{} als vertraute Abhängigkeit deklariert werden. Sobald \glq bcrypt\grq{} als vertraulich markiert ist, verläuft eine erneute Installation aller Pakete erfolgreich.\newline
Die Konsolenausgabe zeigt beim nächsten Start der App einen Laufzeitfehler an: \glq ReferenceError: Cannot access uninitialized variable\grq{}. Dies tritt an den Stellen auf, in denen die Relation zwischen den Entitäten \glq Article\grq{} und \glq User\grq{} definiert werden. Das führt zu einer zirkulären Abhängigkeit zwischen \glq User\grq{} und \glq Article\grq{}. Dies kann, wie in \cite{TypeORM.} beschrieben, vermieden werden, indem bei der Definition der Relation der Typ \glq User\grq{} durch \glq Relation<User>\grq{} ersetzt wird. Dann löst TypeORM die Definitionen entsprechend auf, ohne dabei zirkuläre Abhängigkeiten zu erzeugen.\\

\noindent
Die Konsole zeigt beim erneuten Start der Applikation keine Fehler mehr. Das Senden einer HTTP-Anfrage an die API liefert die Fehlermeldung \glq Die Metadaten für die Entität User können nicht gefunden werden\grq{}. TypeORM sucht aktuell alle Entitäten über einen String, der ein Pattern für den Pfad der Entitäten definiert. Laut \cite{TypeORM.2021} ist diese Variante veraltet. Die Entitäten müssen direkt als Referenz übergeben werden, indem sie über einen Import inkludiert werden. \newline
Ein erneuter Start der App ist erfolgreich. Allerdings stürzt der Server mit der Meldung \glq Segmentation Fault\grq{} ab, sobald sich ein neuer Benutzer registriert oder ein vorhandener Benutzer einloggt. Über die Log-Einträge kann nachvollzogen werden, dass der Server abstürzt, sobald \glq bcrypt\grq{} zum Hashen der Passwörter aufgerufen wird. Laut \cite{Sumner.2023} funktioniert \glq bcrypt\grq{} nicht, wenn es asynchron aufgerufen wird. Ein synchroner Aufruf der entsprechenden Funktionen verläuft allerdings erfolgreich. Da ein synchroner Aufruf dieser Funktion die Ausführung anderer Aufgaben blockiert, ist diese Lösung nicht optimal. Bun bietet für diesen Zweck eine eigene API an. Durch die Verwendung dieser funktioniert das Registrieren und Einloggen von Benutzern wieder. Die anderen Endpunkte der API funktionieren auch. Daraus folgt, dass Nest unter Bun funktioniert. Allerdings bedeutet der Wechsel auf die API von Bun, dass das Versprechen eines Eins-zu-Eins-Ersatzes für Node.js nicht gehalten werden kann, da die Migration aktive Eingriffe in die Abhängigkeiten der Applikation erfordert.\\

\noindent
Im letzten Test wird, wie bei Express zuvor, versucht die minifizierte Version der Anwendung zu erzeugen und lokal auszuführen. Ein Aufruf des Bundlers liefert zahlreiche Fehlermeldungen. Der Bundler meldet viele Abhängigkeiten, die er nicht auflösen kann. Auffällig ist, dass die als fehlend deklarierten Abhängigkeiten in den direkten Abhängigkeiten des Projekts nicht vorhanden sind. \cite{Postek.2023} zeigt, dass bereits andere Entwickler mit demselben Problem konfrontiert sind. Da dieses Problem derzeit ungelöst ist, funktioniert der Bundler für Nest nicht.

\section{Fazit} \label{sec:compabitility-conclusion}
Dieses Kapitel beantwortet die zweite Leitfrage \glqq Inwiefern sind Node.js-Projekte kompatibel mit Bun? Wie schwierig gestaltet sich die Migration?\grqq{} (siehe \autoref{sec:introduction-target}). Die Migration von Node.js-Projekten auf Bun kann erfolgreich sein, erfordert jedoch in der Regel Anpassungen in den Abhängigkeiten und Konfigurationen. Der Aufwand hängt stark von der Applikation und den verwendeten Abhängigkeiten ab. Beispielsweise erfordert die Umstellung der Nest-Applikation zusätzliche Anpassungen, insbesondere bei der asynchronen Verwendung von \glq bcrypt\grq{}. Obwohl die Anwendung mit Bun ausgeführt werden kann, ist festzustellen, dass die Migration aktive Eingriffe in die Abhängigkeiten der Anwendung erfordert. Zusätzlich funktioniert der Bundler nicht. Die Tatsache, dass die minifizierte Version der Nest-Anwendung unter Bun nicht generiert werden kann, wirft Fragen zur Stabilität und Zuverlässigkeit von Bun auf.\\

\noindent
Es gilt anzumerken, dass die verwendeten Beispiele einfache Applikationen darstellen. Produktiv genutzte Anwendungen können komplexer sein und mehr Abhängigkeiten verwenden. Beide Beispiele beweisen, dass häufig verwendete Komponenten und Konzepte funktionieren können. Dazu zählen Authentifizierung und Autorisierung, Logging, \ac{crud}-Operationen für Entitäten, Integration mit einer Datenbank und Schutzmechanismen für die Applikation selbst. Auf diesen Konzepten bauen auch produktiv genutzte Anwendungen auf. Sobald es über diese Konzepte hinausgeht, muss die Funktionsweise unter Bun separat analysiert werden.