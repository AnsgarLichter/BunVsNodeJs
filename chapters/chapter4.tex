% !TeX root = ..\main.tex
\npchapter{Kompatibilität von Projekten}  \label{compabitility}
Dieses Kapitel betrachtet die Kompatibilität zwischen Node.js und Bun. Es beschäftigt sich mit der Beantwortung der zweiten Leitfrage ``Inwiefern sind Node.js-Projekte kompatibel mit Bun? Wie schwierig gestaltet sich die Migration?''. Nur wenn der Migrationsaufwand für den Wechsel der Laufzeitumgebung möglichst gering und einfach ist, kann Bun Node.js als Platzhirsch verdrängen. Die Betrachtung konzentriert sich auf die Kompatibilität häufig verwendeter Backend-Frameworks, da diese auf einem Server direkt von Bun oder Node.js ausgeführt werden. Laut der Umfrage ``State of JavaScript 2022'' handelt es sich dabei um Express und NestJS \cite{Greif.2022}.

\section{Express} \label{sec:compabitility-newProjects}
Express ist ein beliebtes Open-Source-Framework für Node.js, das die Entwicklung von Webanwendungen und APIs vereinfacht. Dafür stellt es eine Vielzahl von Funktionen und Tools zur Verfügung, die Entwicklern bei der Handhabung von HTTP-Anfragen und -Antworten, Routing und weiteren Aufgaben helfen. Express nutzt ausschließlich die HTTP-Schnittstelle der Node.js-API. Diese Schnittstelle ist bereits in Bun implementiert (siehe Kapitel \ref{sec:foundations-Bun}).\\

\noindent 
Um die Kompatibilität von Express mit Bun zu testen, wird eine einfache Anwendung genutzt, die das Erstellen, Aktualisieren, Lesen und Löschen von Büchern und Autoren über eine API ermöglicht. Die API nutzt Express in Verbindung mit TypeScript. Sie wird um einige Middleware-Funktionalitäten erweitert, um die Migration repräsentativer zu gestalten. Dazu gehören:
\begin{itemize}
	\item Winston als Logger zur transparenten Verarbeitung der HTTP-Anfragen und zur Fehleranalyse während der Migration,
	\item Helmet zum Schutz der API,
	\item Morgan zur Protokollierung der ein- und ausgehenden HTTP-Anfragen,
	\item Mongoose als ORM zur Speicherung von Daten in MongoDB, \todo{Abkürzungsverzeichnis und erklären?}
	\item Joi zur Validierung der Bücher und Autoren in den HTTP-Anfragen,
	\item Compression zur Komprimierung der HTTP-Antworten,
	\item Ein zentraler Error-Handler, um bei Fehlern verständliche Nachrichten in die HTTP-Anfragen einzufügen.
\end{itemize}
	
\noindent
Um die App von Node.js auf Bun zu migrieren, muss Buns integrierter Paketmanager verwendet werden, um die passenden Abhängigkeiten zu installieren. Node.js speichert die installierten Abhängigkeiten in der ``package.json''. Diese nutzt auch Buns Paketmanager. Für eine komplette Neuinstallation werden der Ordner ``node\_modules'' und die Datei ``package-lock.json'' gelöscht. In diesem Ordner speichert Node.js alle lokal installierten Abhängigkeiten. Node.js nutzt die ``package-lock.json'', um die installierten Abhängigkeiten lokal zu speichern. Dies sorgt dafür, dass die Versionen installiert werden, die während der Entwicklung verwendet wurden. \newline
Im zweiten Schritt müssen veraltete Abhängigkeiten aus dem Projekt entfernt und weitere benötigte Abhängigkeiten hinzugefügt werden. Die Typdefinitionen von Node.js und die Pakete, die es unter Node.js ermöglichen, TypeScript auszuführen (siehe Kapitel \ref{sec:foundations-Node.js), werden unter Bun nicht mehr benötigt. Als Abhängigkeit müssen die Typdefinitionen von Bun hinzugefügt werden. Diese werden auch in der Datei "ts-config.json" inkludiert, damit global auf Buns API ohne Kompilierungsfehler zugegriffen werden kann. Diese Datei definiert Einstellungen und Optionen für den TypeScript-Compiler. Zusätzlich werden die Einstellungen an die Empfehlungen aus der Dokumentation von Bun angepasst \cite{OvenSh.2023}.\newline 
Im dritten Schritt werden die Befehle in der ``package.json'' angepasst, die die Ausführung des Projekts ermöglichen. Zum Ausführen des Projekts wird ab sofort ``bun --watch src/index.ts'' genutzt. Zuletzt müssen die Pakete mit Buns Paketmanager installiert werden, indem der Befehl ``bun install'' ausgeführt wird. Nachfolgend kann nun über der angepasste Befehl genutzt werden, um die Anwendung zu starten.\\

\noindent
Der erste Start der App ist nicht erfolgreich. Die Konsolenausgabe zeigt den Fehler an ``SyntaxError: Import named 'Request' not found in module 'node\_modules/express/index.js''. Das bedeutet, dass der Compiler den Import des Typs 'Request' aus dem Express-Framework nicht auflösen kann. Um die generelle Funktionsweise der App zu verifizieren, werden die Importe aller Typen aus dem Express-Framework entfernt. Ein erneuter Start der App bestätigt dies. Da es sich um ein Problem mit den Typdefinition handelt, liegt die Vermutung nahe, dass eine Einstellung des TypeScript-Compilers die Ursache ist. Eine minimale Express-App mit den offiziell empfohlenen ``ts-config.json'' zeigt, dass die App auch mit den verwendeten Typen funktioniert. Der Unterschied in der ``ts-config.json'' beider Projekte zeigt, dass im aktuellen Projekten ``emitDecoratorMetadata'' aktiviert ist. Diese Option steuert, ob der Compiler Metadaten über Dekoratoren im generierten JavaScript-Quellcode generiert. Ist diese Option aktiviert, kann zur Laufzeit auf die Metadaten der Dekoratoren zugegriffen werden. Mit der deaktivierten Option läuft die App. Das Absenden von HTTP-Anfragen an die Applikation zeigt, dass alle API-Operationen erfolgreich funktionieren.\\

\noindent
Wenn man die App nun produktiv nutzen möchte, verwendet man minifizierten Quellcode. Dieser wird mit Hilfe eines Bundlers erstellt. Bun bietet einen integrierten Bundler an (siehe Kapitel \ref{sec:foundations-Bun}). Dieser wird durch den Befehl ``bun build src/index.ts --outdir ./dist --target bun'' erzeugt. Wichtig ist hierbei, Bun als Zielplattform zur Ausführung zu spezifizieren. Denn alternativ kann auch Node.js als Zielplattform genutzt werden. Führt man nun das Ergebnis des Bundlers aus, erscheint eine kryptische Fehlermeldung: ``TypeError: d is not a function. (In 'd(target, key, r)', 'd' is an instance of Object)''. Eine Analyse zeigt, dass ein verwendeter Dekorator nicht funktioniert. Der verwendete Dekorator sorgt, dass beim Binding der Listener für die API-Funktionen  der this-Kontext innerhalb des Listeners funktioniert. Dies muss nun manuell über angepassten Quellcode erledigt werden. Nun startet die App in der produktiven Nutzung ohne Fehler. Das Absenden von HTTP-Anfragen an die Applikation zeigt, dass auch alle API-Operationen erfolgreich funktionieren. Offiziell handelt es sich bei der Option ``experimentalDecorators'' um ein experimentelles Feature, das von Node.js bereits unterstützt wird und von Bun noch nicht \cite{Microsoft.2023}.

\section{NestJS} \label{sec:compabitility-existingProjects}
Nest.js ist ein Open-Source-Framework für die Entwicklung von serverseitigen Anwendungen und APIs in Node.js \cite{Mysliwiec.2023}. Es wurde entwickelt, um die Erstellung von skalierbaren, gut strukturierten und leicht wartbaren Anwendungen zu erleichtern. Nest.js basiert auf TypeScript und bietet eine Abstraktionsebene über gängige HTTP-Servern wie z. B. Express an. Nest ermöglicht den Entwicklern über APIs andere Server zu benutzen. Bun unterstützt Nest.js noch nicht vollständig \cite{Sumner.2022}. Mit Version 1.0.3 wird der TypeScript-Dekorator ``emitDecoratorMetadata'' unterstützt, auf dem Nest.js aufbaut \cite{McDonnel.}. Dadurch wird der Support von Nest.js verbessert.\\

\noindent
Zur Prüfung der Kompatibilität wird eine App verwendet, die es ermöglicht über eine API Artikel zu erstellen, aktualisieren, lesen und zu löschen. Der Autor ist ein Benutzer, der sich zuvor Registrieren muss. Die Anwendung verwendet die folgenden Features:

\begin{itemize}
	\item Rollenbasierte Authentifizierung und Autorisierung,
	\item ORM-Integration mit TypeORM,
	\item Logging mit Winston,
	\item Validierungen mit Joi.
\end{itemize}

\noindent
Als Datenbank wird eine lokale PostgreSQL-Instanz verwendet. Den Verbindungsaufbau übernimmt TypeORM unter Angabe der korrekten Daten. Die Migration startet wie bei Express mit dem Löschen der installierten Abhängigkeiten und der ``package-lock.json''. Im zweiten Schritt werden die nicht mehr benötigten Abhängigkeiten, z. B. die Typendefinitionen von Node.js, entfernt. Es werden wieder die Typdefinitionen von Bun hinzugefügt. Im dritten Schritt wird die ``ts-config.json'' an die Empfehlungen von Bun angepasst und die Typdefinitionen von Bun inkludiert \cite{OvenSh.2023}. Die Optionen, die Bun als Best Practices bezeichnet, werden nicht übernommen. Denn diese sind in den Best Practices von Nest.js explizit nicht enthalten. Im vierten Schritt werden die Befehle in der ``package.json'' angepasst, um die Applikation starten zu können. Abschließend werden die Abhängigkeiten über Buns Paketmanager installiert.\newline
Beim Start der App erscheint nun die Fehlermeldung ``Error: Cannot find module 'node\_modules/bcrypt/lib/binding/napi-v3/bcrypt\_lib.node'''. Das Paket ``bcrypt'' wird verwendet, um die Passwörter zu hashen und beim Login zu validieren. Bcrypt nutzt node-gyp als Abhängigkeit \todo{Quelle: https://github.com/kelektiv/node.bcrypt.js}. Dabei handelt es sich um ein Open-Source-Build-Tool, das zum Erstellen und Kompilieren nativer Node Module eingesetzt wird \todo{Quelle?}. In diesem Kontext wird oft postinstall verwendet, eine Lifecycle-Methode beim Installieren der Abhängigkeiten. Im Anschluss an die Installation des Pakets wird ein Skript ausgeführt, um beispielsweise einen Build auszuführen. Bun blockiert diese standardmäßig, da diese Skripte potentielle Sicherheitsrisiken darstellen. Vertraut man einem Paket, muss man dieses in der ``package.json'' als vertraute Abhängigkeit deklarieren \todo{https://bun.sh/guides/install/trusted}. Fügt man nun Bcrypt hinzu und installiert alle Pakete komplett neu, ist der Fehler gelöst. \newline
Die Konsolenausgabe zeigt beim erneuten Start der App einen Laufzeitfehler an: ``ReferenceError: Cannot access uninitialized variable.''. Abbildung TODO zeigt die Stelle, die diese Fehlermeldung verursacht. Die Entität ``Article'' definiert eine Relation zu der Entiät ``User''. Das führt zu einer zirkulären Abhängigkeit zwischen ``User'' und ``Article''. Die Dokumentation von TypeORM zeigt, dass zirkuläre Abhängigkeiten vermieden werden können, wenn ``User'' durch ``Relation<User>'' ersetzt wird. Dann löst TypeORM die Definitionen entsprechend auf, ohne dabei zirkuläre Importe zu erzeugen. \\

\todo{Code Listing Entity Definition}

\noindent
Die Konsole zeigt beim erneuten Start der Applikation keine Fehler mehr an. Sendet man nun HTTP-Anfragen an die API, wird die Fehlermeldung ``Die Metadaten für die Entität User können nicht gefunden werden.'' zurückgegeben. TypeORM sucht alle Entitäten über ein String geladen, der ein Pattern für den Pfad der Entitäten sucht. Laut Changelog von TypeORM ist diese Variante veraltet \todo{Quelle Changelog TypeORM}. Die Entitäten müssen direkt als Referenz übergeben werden, indem sie über einen Import inkludiert. \newline
Startet man die App erneut und führt HTTP-Anfragen aus, erhält man keine Fehlermeldungen mehr. Allerdings stürzt der Server mit der Meldung ``Segmentation Fault'' ab, sobald ein sich ein neuer Benutzer registrieren oder ein vorhandener Benutzer einloggen möchte. Über die Logs kann nachvollzogen werden, dass der Server abstürzt, sobald Bcrypt zum Hashen der Passwörter aufgerufen wird. Eine Recherche zu dieser Fehlermeldung in Kombination mit Bcrypt hat keine Treffer ergeben und die neuste Version wird bereits verwendet. Daher bleibt nur die Option in der Dokumentation von Bun nach Empfehlungen für das Hashen von Passwörtern zu suchen. Bun bietet hierfür tatsächlich eine eigene API an. Nutzt man diese in der Applikation, sind auch die HTTP-Anfragen zum Registrieren oder Einloggen von Benutzern erfolgreich. Die anderen Endpunkte der API funktioniert auch. Daraus folgt, dass Nest.js unter Bun funktionieren kann. Allerdings bedeutet der Wechsel auf die API von Bun, dass das Versprechen eines Eins-zu-Eins-Ersatzes für Node.js nicht gehalten werden kann. Denn es erfordert aktive Eingriffe in die Abhängigkeiten der Applikation. \\

\noindent
Als letzten Punkt wird, wie bei Express zuvor, versucht die minifizierte Version der Anwendung zu erzeugen und lokal auszuführen. Sobald man den Bundler aufruft zeigt dieser viele Fehlermeldungen an, die in Abbildung TODO zu sehen sind. Auffällig ist, dass die Abhängigkeiten, die hier als fehlend deklariert werden, in den direkten Abhängigkeiten des Projekts nicht vorhanden sind. \todo{Quelle: https://github.com/oven-sh/bun/issues/4803} zeigt, dass bereits andere Entwickler dasselbe Problem besitzen. Da dieses Issue aktuell noch offen ist, funktioniert Buns Bundler für Nest.js noch nicht. Hier gilt es Updates abzuwarten.

\section{Fazit} \label{sec:compabitility-conclusion}
Dieses Kapitel beschäftigt sich mit der zweiten Leitfrage ``Inwiefern sind Node.js-Projekte kompatibel mit Bun? Wie schwierig gestaltet sich die Migration?'' (siehe Kapitel \ref{sec:introduction-target}). Die Ergebnisse dieses Kapitels zeigen, dass Bun Applikationen auf der Basis von Express oder Nest.js ausführen kann. Der Migrationsaufwand hängt stark von der Applikation und den verwendeten Abhängigkeiten ab. Funktionieren nahezu alle Abhängigkeiten problemlos, wie zum Beispiel bei Express, ist die Migration in kurzer Zeit erledigt. Sobald bestimmte Module nicht kompatibel sind und Fehler verursachen, kann der Prozess für die Suche nach der Ursache und die Implementation einer Lösung sehr mehrere Stunden in Anspruch nehmen. Letzendlich hängt die Funktionsfähigkeit eines Moduls davon ab, welche Schnittstelle der Node.js API genutzt werden. Wenn Bun die verwendeten Schnittstellen implementiert hat, funnktionieren die Module. Andernfalls kann die Suche nach der Ursache und nach alternativen Lösungsansätzen zeitintensiv und schwierig werden. Selbst wenn alle verwendeten APIs unterstütz werden, kann es wie bei Bcrypt zu Laufzeitfehlern kommen. Deren Analyse ist als Entwickler, der nicht das Modul selbst entwickelt, äußerst schwierig.\\

\noindent
Es gilt anzumerken, dass die verwendeten Beispiele einfachere Applikationen waren. Produktiv genutzt Anwendungen können komplexer sein und auch mehr Abhängigkeiten verwenden. Beide Beispiele beweisen, dass häufig verwendete Komponenten und Konzepte funktionieren. Dazu zählen Authentifizierung und Autorisierung, Logging, CRUD-Operationen für Entitäten, Integration mit einer Datenbank und auch Schutzmechanismen für die Applikation selbst. Auf diesen Konzepten bauen auch produktiv genutzte Anwendungen auf. Sobald es über diese Konzepte hinausgeht, muss die Funktionsweise unter Bun separat analysiert werden.