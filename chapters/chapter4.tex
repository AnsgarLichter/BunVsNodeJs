% !TeX root = ..\main.tex
\npchapter{Kompatibilität von Projekten}  \label{ch:compabitility}
Dieses Kapitel behandelt die Kompatibilität zwischen Node.js und Bun. Es beschäftigt sich mit der Beantwortung der zweiten Leitfrage ``Inwiefern sind Node.js-Projekte kompatibel mit Bun? Wie schwierig gestaltet sich die Migration?''. Nur wenn der Migrationsaufwand für den Wechsel der Laufzeitumgebung möglichst gering ist, kann Bun Node.js als Platzhirsch verdrängen. Die Betrachtung konzentriert sich auf die Kompatibilität häufig verwendeter Backend-Frameworks, da diese auf einem Server direkt von Bun oder Node.js ausgeführt werden. Laut \cite{Greif.2022} handelt es sich dabei um Express und NestJS.

\section{Express} \label{sec:compabitility-express}
Express ist ein beliebtes Open-Source-Framework für Node.js, das die Entwicklung von Webanwendungen und APIs vereinfacht. Es stellt eine Vielzahl von Funktionen und Tools zur Verfügung, die Entwicklern bei der Handhabung von HTTP-Anfragen und -Antworten, Routing und weiteren Aufgaben zu helfen. Express nutzt ausschließlich die HTTP-Schnittstelle der Node.js-API. Diese implementiert Bun bereits (siehe Kapitel \ref{sec:foundations-Bun}).\cite{Brown.November2019}\\

\noindent 
Um die Kompatibilität von Express mit Bun zu testen, wird eine einfache Anwendung genutzt, die das Erstellen, Aktualisieren, Lesen und Löschen von Büchern und Autoren über eine API ermöglicht. Die API verwendet Express in Verbindung mit TypeScript. Sie wird um einige Middleware-Funktionalitäten erweitert, um die Migration repräsentativer zu gestalten. Dazu gehören:
\begin{itemize}
	\item Winston als Logger,
	\item Helmet zum Schutz der API,
	\item Morgan zur Protokollierung der ein- und ausgehenden HTTP-Anfragen,
	\item Mongoose als ORM zur Speicherung von Daten in MongoDB, \todo{Abkürzungsverzeichnis und erklären?}
	\item Joi zur Validierung der Bücher und Autoren in den HTTP-Anfragen,
	\item Compression zur Komprimierung der HTTP-Antworten,
	\item ein zentraler Error-Handler, um bei Fehlern verständliche Nachrichten an den Benutzer zurückzugeben.
\end{itemize}
	
\noindent
Um die App von Node.js auf Bun zu migrieren, muss Buns integrierter Paketmanager verwendet werden, um die passenden Abhängigkeiten zu installieren. Node.js speichert die installierten Abhängigkeiten in der ``package.json'', die auch von Buns Paketmanager genutzt wird. Für eine komplette Neuinstallation werden der Ordner ``node\_modules'' und die Datei ``package-lock.json'' gelöscht. In diesem Ordner speichert Node.js alle lokal installierten Abhängigkeiten. Node.js nutzt die ``package-lock.json'', um die installierten Abhängigkeiten lokal zu speichern. Dies sorgt dafür, dass die Versionen installiert werden, die während der Entwicklung verwendet wurden. \newline
Im zweiten Schritt müssen veraltete Abhängigkeiten aus dem Projekt entfernt und weitere benötigte Abhängigkeiten hinzugefügt werden. Die Typdefinitionen von Node.js und die Pakete, die es unter Node.js ermöglichen, TypeScript auszuführen (siehe Kapitel \ref{sec:foundations-Node.js}), werden unter Bun nicht mehr benötigt. Als Abhängigkeit müssen die Typdefinitionen von Bun hinzugefügt werden. Diese werden auch in der Datei "ts-config.json" inkludiert, damit global auf Buns API ohne Kompilierungsfehler zugegriffen werden kann. Diese Datei definiert Einstellungen und Optionen für den TypeScript-Compiler. Die Werte der Konfigurationsoptionen, die sowohl in der aktuellen Datei als auch in in Buns Empfehlungen vorhanden sind, werden an den empfohlenen Wert angepasst \cite{OvenSh.2023}.\newline 
Im dritten Schritt werden die Befehle in der ``package.json'' angepasst, die die Ausführung des Projekts ermöglichen. Zum Ausführen des Projekts wird ab sofort ``bun --watch src/index.ts'' genutzt. Zuletzt müssen die Pakete mit Buns Paketmanager installiert werden, indem der Befehl ``bun install'' ausgeführt wird. Danach kann die Anwendung gestartet werden.\\

\noindent
Der erste Start der App ist nicht erfolgreich. Die Konsolenausgabe zeigt den Fehler an ``SyntaxError: Import named Request not found in module node\_modules/express/index.js''. Das bedeutet, dass der Compiler den Import des Typs ``Request'' aus dem Express-Framework nicht auflösen kann. Um die generelle Funktionsweise der App zu überprüfen, werden die Importe aller Typen aus dem Express-Framework entfernt. Ein erneuter Start der App bestätigt die generelle Funktionsweise. Da es sich um ein Problem mit den Typdefinition handelt, liegt die Vermutung nahe, dass eine Einstellung des TypeScript-Compilers die Ursache ist. Eine minimale Express-App mit der empfohlenen Konfiguration des TypeScript-Compilers zeigt, dass die App auch mit den verwendeten Typen funktioniert. Der Vergleich der Konfiguration des Compilers in beiden Projekten zeigt, dass im aktuellen Projekt ``emitDecoratorMetadata'' aktiviert ist. Diese Option steuert, ob der Compiler Metadaten über Dekoratoren im generierten JavaScript-Quellcode generiert. Ist diese Option aktiviert, kann zur Laufzeit auf die Metadaten der Dekoratoren zugegriffen werden. Mit deaktivierter Option startet die App. Das Absenden von HTTP-Anfragen an die Applikation zeigt, dass alle API-Operationen erfolgreich funktionieren.\\

\noindent
Wenn man die App nun produktiv nutzen möchte, verwendet man minifizierten Quellcode, der mit Hilfe eines Bundlers erstellt wird. Bun bietet einen integrierten Bundler an (siehe Kapitel \ref{sec:foundations-Bun}). Dieser wird durch den Befehl ``bun build src/index.ts --outdir ./dist --target bun'' erzeugt. Dabei ist es wichtig, Bun als Zielplattform zur Ausführung zu spezifizieren, da alternativ auch Node.js als Zielplattform genutzt werden kann. Führt man nun das Ergebnis des Bundlers aus, erscheint eine kryptische Fehlermeldung: ``TypeError: d is not a function. (In d(target, key, r), d is an instance of Object)''. Die Analyse zeigt, dass ein verwendeter Dekorator nicht funktioniert. Dieser sorgt dafür, dass beim Binding der Listener für die API-Funktionen  der this-Kontext innerhalb des Listeners funktioniert. Dies muss nun manuell über angepassten Quellcode erledigt werden. Nun startet die App in der produktiven Nutzung ohne Fehler. Das Absenden von HTTP-Anfragen an die Applikation zeigt, dass auch alle API-Operationen erfolgreich funktionieren. Offiziell handelt es sich bei der Option ``experimentalDecorators'' um ein experimentelles Feature, das von Node.js bereits unterstützt wird und von Bun noch nicht \cite{Microsoft.2023}.

\section{NestJS} \label{sec:compabitility-nestjs}
NestJS ist ein Open-Source-Framework für die Entwicklung von serverseitigen Anwendungen und APIs in Node.js \cite{Mysliwiec.2023}. Es wurde entwickelt, um die Erstellung von skalierbaren, gut strukturierten und leicht wartbaren Anwendungen zu erleichtern. NestJS basiert auf TypeScript und bietet eine Abstraktionsebene über gängige HTTP-Servern wie z. B. Express an. NestJS ermöglicht den Entwicklern über APIs andere Server zu benutzen. Bun unterstützt NestJS noch nicht vollständig \cite{Sumner.2022}. Mit Version 1.0.3 wird der TypeScript-Dekorator ``emitDecoratorMetadata'' unterstützt, auf dem NestJS aufbaut \cite{McDonnel.2023}. Dadurch wird der Support von NestJS verbessert.\\

\noindent
Zur Prüfung der Kompatibilität wird eine App verwendet, die es ermöglicht über eine API Artikel zu erstellen, aktualisieren, lesen und zu löschen. Der Autor ist ein Benutzer, der sich zuvor registrieren muss. Die Anwendung verwendet die folgenden Features:

\begin{itemize}
	\item Rollenbasierte Authentifizierung und Autorisierung,
	\item ORM-Integration mit TypeORM,
	\item Logging mit Winston,
	\item Validierungen mit Joi.
\end{itemize}

\noindent
Als Datenbank wird eine lokale PostgreSQL-Instanz verwendet. Den Verbindungsaufbau übernimmt TypeORM unter Angabe der korrekten Daten. Die Schritte der Migration entsprechen bis zum ersten Ausführen der Applikation der Migration von Express (siehe Kapitel \ref{sec:compabitility-express}). Daher wird im Folgenden nur die Unterschiede betrachtet. Die Konfiguration des Compilers entspricht den Empfehlungen. Lediglich die Optionen, die Bun als Best Practices deklariert, werden nicht übernommen. Denn diese sind in den Best Practices von NestJS explizit nicht enthalten. \newline
Beim Start der App erscheint nun die Fehlermeldung ``Error: Cannot find module node\_modules/bcrypt/lib/binding/napi-v3/bcrypt\_lib.node''. Das Paket ``bcrypt'' wird verwendet, um die Passwörter zu hashen und beim Login zu validieren. Bcrypt nutzt node-gyp als Abhängigkeit \cite{DelGobbo.2018}. Dabei handelt es sich um ein Open-Source-Build-Tool, das zum Erstellen und Kompilieren nativer Node Module eingesetzt wird \cite{OpenJSFoundation.o.J.b}. In diesem Kontext wird oft ``postinstall'' verwendet, eine Lifecycle-Methode beim Installieren der Abhängigkeiten. Im Anschluss an die Installation des Pakets wird ein Skript ausgeführt, um beispielsweise einen node-gyp auszuführen. Bun blockiert diese standardmäßig, da diese Skripte potentielle Sicherheitsrisiken darstellen \cite{OvenSh.2023}. Vertraut man einem Paket, muss man dieses in der ``package.json'' als vertraute Abhängigkeit deklarieren. Fügt man nun Bcrypt hinzu und installiert alle Pakete komplett neu, ist der Fehler gelöst. \newline
Die Konsolenausgabe zeigt beim nächsten Start der App einen Laufzeitfehler an: ``ReferenceError: Cannot access uninitialized variable.''. Dies tritt an der Stellen auf, in denen die Relation zwischen den Entitäten ``Article''und ``User'' definiert werden. Das führt zu einer zirkulären Abhängigkeit zwischen ``User'' und ``Article''. \cite{TypeORM.} zeigt, dass zirkuläre Abhängigkeiten vermieden werden können, wenn ``User'' durch ``Relation<User>'' ersetzt wird. Dann löst TypeORM die Definitionen entsprechend auf, ohne dabei zirkuläre Importe zu erzeugen.\\

\noindent
Die Konsole zeigt beim erneuten Start der Applikation keine Fehler mehr. Sendet man nun HTTP-Anfragen an die API, wird die Fehlermeldung ``Die Metadaten für die Entität User können nicht gefunden werden.'' zurückgegeben. TypeORM sucht aktuell alle Entitäten über ein String, der ein Pattern für den Pfad der Entitäten definiert. Laut \cite{TypeORM.2021} ist diese Variante veraltet. Die Entitäten müssen direkt als Referenz übergeben werden, indem sie über einen Import inkludiert werden. \newline
Startet man die App erneut und führt HTTP-Anfragen aus, erhält man keine Fehlermeldungen mehr. Allerdings stürzt der Server mit der Meldung ``Segmentation Fault'' ab, sobald sich ein neuer Benutzer registriert oder ein vorhandener Benutzer einloggt. Über die Log-Einträge kann nachvollzogen werden, dass der Server abstürzt, sobald Bcrypt zum Hashen der Passwörter aufgerufen wird. Eine Recherche zu dieser Fehlermeldung in Kombination mit Bcrypt hat keine Treffer ergeben und die neuste Version wird bereits verwendet. Daher bleibt nur die Option in der Dokumentation von Bun nach Empfehlungen für das Hashen von Passwörtern zu suchen. Bun bietet hierfür eine eigene API an. Nutzt man diese in der Applikation, sind auch die HTTP-Anfragen zum Registrieren oder Einloggen von Benutzern erfolgreich. Die anderen Endpunkte der API funktionieren auch. Daraus folgt, dass NestJS unter Bun funktioniert. Allerdings bedeutet der Wechsel auf die API von Bun, dass das Versprechen eines Eins-zu-Eins-Ersatzes für Node.js nicht gehalten werden kann, da die Migration aktive Eingriffe in die Abhängigkeiten der Applikation erfordert.\\

\noindent
Als letzten Punkt wird, wie bei Express zuvor, versucht die minifizierte Version der Anwendung zu erzeugen und lokal auszuführen. Sobald man den Bundler aufruft, zeigt dieser zahlreiche Fehlermeldungen an. Der Bundler meldet viele Abhängigkeiten, die er nicht auflösen kann.  Auffällig ist, dass die als fehlend deklarierten Abhängigkeiten in den direkten Abhängigkeiten des Projekts nicht vorhanden sind. \cite{Postek.2023} zeigt, dass bereits andere Entwickler mit demselben Problem konfrontiert sind. Da dieses Problem derzeit ungelöst ist, funktioniert der Bundler für NestJS nicht. Hier bleibt abzuwarten, bis Updates veröffentlicht werden.

\section{Fazit} \label{sec:compabitility-conclusion}
Dieses Kapitel beschäftigt sich mit der zweiten Leitfrage ``Inwiefern sind Node.js-Projekte kompatibel mit Bun? Wie schwierig gestaltet sich die Migration?'' (siehe Kapitel \ref{sec:introduction-target}). Die Migration von Node.js-Projekten auf Bun kann erfolgreich sein, erfordert jedoch in der Regel Anpassungen in den Abhängigkeiten und Konfigurationen. Der Aufwand hängt stark von der Applikation und den verwendeten Abhängigkeiten ab. Beispielsweise erfordert die Umstellung der NestJS-Applikation zusätzliche Anpassungen, insbesondere bei der Verwendung von Bcrypt. Obwohl die Anwendung unter Bun funktioniert, ist festzustellen, dass die Migration aktive Eingriffe in die Abhängigkeiten der Anwendung erfordert. Zusätzlich funktioniert der Bundler nicht.  Die Tatsache, dass die minifizierte Version der NestJS-Anwendung unter Bun nicht funktionierte, wirft Fragen zur Stabilität und Zuverlässigkeit von Bun auf. Es bleibt abzuwarten, ob zukünftige Updates diese Probleme beheben können.\\

\noindent
Es gilt anzumerken, dass die verwendeten Beispiele einfachere Applikationen waren. Produktiv genutzte Anwendungen können komplexer sein und auch mehr Abhängigkeiten verwenden. Beide Beispiele beweisen, dass häufig verwendete Komponenten und Konzepte funktionieren. Dazu zählen Authentifizierung und Autorisierung, Logging, CRUD-Operationen für Entitäten, Integration mit einer Datenbank und auch Schutzmechanismen für die Applikation selbst. Auf diesen Konzepten bauen auch produktiv genutzte Anwendungen auf. Sobald es über diese Konzepte hinausgeht, muss die Funktionsweise unter Bun separat analysiert werden.